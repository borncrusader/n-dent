CLIENT:
-------

PERIODIC THREAD
---------------
struct buffer {
	int eof_pkt;			// set by periodic thread to mark eof
	int seq_beg, seq_end;		// set by periodic thread begin and end of seq numbers of pakets sent so far
	int N, unack, avail, empty;  	// N is the window size, unack is the number unacked so far, available is num nodes with data, empty is free space in win
	int timer;			// timer for oldest unacked pkt
	pthread_mutext_lock lck;	// a lock for the structure
	struct window *head;		// head of window
	struct window *left, *right;	// left & right boundary of window
	struct window *tosend;		// yet to send data
};

struct window {
	int acks[recv];			// used by receiver
	char buf[MSS];			// place to store data
	struct window *next;		// pointer to next
};

PERIODIC THREAD
---------------
ADD NODES TO THE BUFFER BEFOREHAND
Number of nodes in the buffer = N
Called periodically
Acquire lock
Check if empty > 0 then add new nodes.
else sleep


SEND THREAD
-----------
periodically wakes up
TAKE LOCK
for every_Pkt {
  for every_receiver {
    MAKE HEADER FOR EVERY PACKET TO SEND TO EVERY RECEIVER
    sendto()
  }
}

RECEIVE THREAD
--------------
recvfrom()
unpack()
Check for ACK 
if ACK for CORRECT SYN 
  INC ACKS ARRAY FOR THIS RECEIVER
  if ACK[RECV] == 3 retransmit to all RECEIVER NOT ACKED YET
  else Advance Window (delete nodes)
else
  increment 
------------------------------------------------------------------------------------------------------

SERVER:

RECVFROM the packet
RANDOM NUMBER Q
DROP IF Q <= P ELSE
CALCULATE CHECKSUM
IF EXPECTED SEQ NUMBER ? SEND ACK, WRITE MAX DATA POSSIBLE: BUFFER PKT
IF LAST PKT CLOSE SOCKET
